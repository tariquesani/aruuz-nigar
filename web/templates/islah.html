{% extends "base.html" %}

{% block title %}Urdu Poetry Islah Tool — Aruuz Nigar{% endblock %}

{% block extra_head %}
<style>
    [x-cloak] {
        display: none !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="container my-5" x-data="islahApp()" x-cloak>
    <h1 class="text-center mb-4">Aruuz Nigar: Urdu Poetry Islah Tool</h1>
    <div class="alert alert-light border mb-2 py-1" role="alert">
        <small class="text-muted">
            <strong>Legend:</strong>
            <span class="ms-2"><code class="text-dark">–</code> short syllable</span>
            <span class="ms-3"><code class="text-dark">=</code> long syllable</span>
            <span class="ms-3"><code class="text-dark">X</code> flexible (short or long)</span>
        </small>
    </div>
    <!-- Scansion grid: original line above, then words/syllables/feet rows -->
    <div class="my-3" x-show="result && displayCode">
        <!-- Original line above grid (same as index.html) -->
        <h5 class="text-center urdu-text mb-4" dir="rtl" lang="ur" x-text="result && result.original_line ? result.original_line : ''"></h5>
        <!-- Centered grid: words, syllables, feet -->
        <div class="scansion-grid-wrapper">
            <!-- Words row -->
            <div class="scansion-row words-row">
                <template x-for="wordData in wordsWithBoundaries" :key="wordData.word_index">
                    <div class="word-cell" :style="`grid-column: span ${wordData.span}`" x-text="wordData.word"></div>
                </template>
            </div>
            <!-- Syllables row -->
            <div class="scansion-row">
                <template x-for="(syllable, i) in syllablesWithDeviations" :key="i">
                    <span class="syllable" :class="syllable.deviationType || ''" x-text="syllable.char || ''"></span>
                </template>
            </div>
            <!-- Feet row -->
            <div class="scansion-row feet-row">
                <template x-for="(footData, footIndex) in feetWithBoundaries" :key="footData.start">
                    <div class="foot-cell" :class="{ 'foot-cell-alt': footIndex % 2 === 1 }" :style="`grid-column: span ${footData.span}`" x-text="footData.foot"></div>
                </template>
            </div>
        </div>
        <!-- Bahr line below grid: Exact match: / Almost matches: + meter name (+ deviation messages on same line when inferred) -->
        <div class="text-center mt-3" x-show="bahrLabel && bahrName">
            <h6><span x-text="bahrLabel"></span><span dir="rtl" lang="ur" class="urdu-text" :data-bs-title="bahrTooltip" :data-bs-toggle="bahrTooltip ? 'tooltip' : null" data-bs-placement="top" x-text="bahrName"></span><span class="small text-muted" x-show="deviationsExplanationLine" x-text="deviationsExplanationLine ? '. ' + deviationsExplanationLine : ''"></span></h6>
        </div>
    </div>

    <form @submit.prevent="submit" class="mb-4">
        <div class="mb-3">
            <label for="islah-text" class="form-label">Enter Urdu Poetry Lines (one per line)</label>
            <textarea id="islah-text" class="form-control form-control-lg urdu-input mb-3" dir="rtl" lang="ur" rows="5"
                placeholder="Start typing your poetry here..." x-model="text" :disabled="loading"
                @keydown.space="setTimeout(() => silentUpdate(), 0)"></textarea>
        </div>
        <button type="submit" class="btn btn-primary" :disabled="loading">
            <span x-show="!loading">Submit</span>
            <span x-show="loading">Submitting…</span>
        </button>
    </form>


    <div x-show="response !== ''">
        <label class="form-label">Response</label>
        <pre class="bg-light border rounded p-3 overflow-auto mb-0" x-text="response"></pre>
    </div>

</div>

<script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js"></script>
<script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('islahApp', () => ({
            text: '',
            response: '',
            result: null,
            loading: false,
            debounceTimer: null,

            init() {
                this.$watch('text', (value) => {
                    if (this.debounceTimer) clearTimeout(this.debounceTimer);
                    if (value.trim()) {
                        this.debounceTimer = setTimeout(() => {
                            this.debounceTimer = null;
                            if (!this.loading) this.silentUpdate();
                        }, 3000);
                    }
                });
            },

            get displayCode() {
                if (!this.result) return '';
                const useMeterPattern = this.result.analysis_level === 'meter' &&
                    (this.result.summary?.conforms_exactly === true || !!this.result.inferred_meter) &&
                    this.result.meter_pattern;
                return useMeterPattern ? this.result.meter_pattern : (this.result.full_code || '');
            },

            get wordsWithBoundaries() {
                if (!this.result || !this.result.word_boundaries || !this.result.original_line) {
                    return [];
                }

                // Split original line into words (handle Urdu text - split on spaces)
                const words = this.result.original_line.trim().split(/\s+/).filter(w => w.length > 0);
                const boundaries = this.result.word_boundaries;

                // Account for insertions when calculating span
                const deviations = this.result.deviations || [];
                const insertions = deviations.filter(dev => dev.type === 'insert');

                return boundaries.map(wb => {
                    // Calculate span accounting for insertions within this word's range
                    let span = wb.code_end - wb.code_start;
                    insertions.forEach(ins => {
                        if (ins.code_pos >= wb.code_start && ins.code_pos < wb.code_end) {
                            span += 1; // Each insertion adds one column
                        }
                    });

                    return {
                        word_index: wb.word_index,
                        word: words[wb.word_index] || '',
                        span: span,
                    };
                });
            },

            get syllablesWithDeviations() {
                const codeStr = this.displayCode;
                if (!this.result || !codeStr) {
                    return [];
                }

                const code = codeStr.split('');
                const deviations = this.result.deviations || [];

                // Build a map of deviations by code_pos
                const deviationMap = new Map();
                deviations.forEach(dev => {
                    if (dev.type === 'substitute' || dev.type === 'delete') {
                        deviationMap.set(dev.code_pos, dev);
                    }
                });

                // Build array of syllables with deviation info
                const syllables = code.map((char, index) => ({
                    char: char,
                    index: index,
                    deviationType: deviationMap.has(index) ? deviationMap.get(index).type : null,
                    expected: deviationMap.has(index) ? deviationMap.get(index).expected : null,
                }));

                // Insert placeholder entries for insertions (sorted by code_pos descending to maintain order)
                const insertions = deviations
                    .filter(dev => dev.type === 'insert')
                    .sort((a, b) => b.code_pos - a.code_pos); // Sort descending to insert from end

                insertions.forEach(ins => {
                    // Insert at code_pos (before the syllable at that position)
                    syllables.splice(ins.code_pos, 0, {
                        char: '',
                        index: ins.code_pos,
                        deviationType: 'insert',
                        expected: ins.expected,
                    });
                });

                return syllables;
            },

            get feetWithBoundaries() {
                if (!this.result || !this.result.feet_list || !this.result.full_code) {
                    return [];
                }

                const feet = this.result.feet_list;
                const deviations = this.result.deviations || [];
                const insertions = deviations.filter(dev => dev.type === 'insert');

                return feet.map(seg => {
                    // Base span from start/end in code indices
                    let span = seg.end - seg.start;

                    // Account for insertions that fall within this foot's range
                    insertions.forEach(ins => {
                        if (ins.code_pos >= seg.start && ins.code_pos < seg.end) {
                            span += 1;
                        }
                    });

                    return {
                        foot: seg.foot,
                        start: seg.start,
                        span: span,
                    };
                });
            },

            get bahrLabel() {
                if (!this.result || this.result.analysis_level !== 'meter') return '';
                if (this.result.summary && this.result.summary.conforms_exactly === true) return 'Exact match: ';
                if (this.result.inferred_meter && this.result.inferred_meter.meter_name) return 'Almost matches: ';
                return '';
            },

            get bahrName() {
                if (!this.result || this.result.analysis_level !== 'meter') return '';
                if (this.result.summary && this.result.summary.conforms_exactly === true && this.result.meters && this.result.meters[0]) {
                    return this.result.meters[0].meter_name || '';
                }
                if (this.result.inferred_meter && this.result.inferred_meter.meter_name) {
                    return this.result.inferred_meter.meter_name;
                }
                return '';
            },

            get bahrTooltip() {
                if (!this.result) return '';
                if (this.result.inferred_meter && this.result.inferred_meter.meter_roman) return this.result.inferred_meter.meter_roman;
                if (this.result.meters && this.result.meters[0] && this.result.meters[0].meter_roman) return this.result.meters[0].meter_roman;
                return '';
            },

            get deviationsExplanation() {
                if (!this.result || !this.result.inferred_meter || !this.result.deviations || !this.result.deviations.length) {
                    return [];
                }
                return this.result.deviations.map(dev => {
                    const pos = dev.code_pos;
                    if (dev.type === 'substitute') {
                        return `Substitute ${dev.current ?? ''} with ${dev.expected ?? ''} at position ${pos}.`;
                    }
                    if (dev.type === 'insert') {
                        return `Insert ${dev.expected ?? ''} at position ${pos}.`;
                    }
                    if (dev.type === 'delete') {
                        return `Delete ${dev.current ?? ''} at position ${pos}.`;
                    }
                    return '';
                }).filter(Boolean);
            },

            get deviationsExplanationLine() {
                const lines = this.deviationsExplanation;
                return lines.length ? lines.join(' ') : '';
            },

            async submit() {
                return this.doFetch(true);
            },

            async silentUpdate() {
                return this.doFetch(false);
            },

            async doFetch(explicit) {
                if (this.debounceTimer) {
                    clearTimeout(this.debounceTimer);
                    this.debounceTimer = null;
                }
                const textarea = document.getElementById('islah-text');
                if (explicit) this.loading = true;
                try {
                    const res = await fetch('/api/islah', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text: this.text }),
                    });
                    const raw = await res.text();
                    if (!res.ok) {
                        this.response = raw || `HTTP ${res.status}`;
                        this.result = null;
                    } else {
                        try {
                            this.result = JSON.parse(raw);
                            this.response = raw;
                        } catch (_) {
                            this.result = null;
                            this.response = raw;
                        }
                    }
                } catch (err) {
                    this.response = err.message || 'Request failed';
                } finally {
                    if (explicit) this.loading = false;
                    if (explicit) this.$nextTick(() => textarea?.focus());
                }
            },
        }));
    });
</script>
{% endblock %}