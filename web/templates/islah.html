{% extends "base.html" %}

{% block title %}Urdu Poetry Islah Tool — Aruuz Nigar{% endblock %}

{% block extra_head %}
<style>
    [x-cloak] {
        display: none !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="container my-5" x-data="islahApp()" x-cloak>
    <h1 class="text-center mb-4">Aruuz Nigar: Urdu Poetry Islah Tool</h1>
    <div class="alert alert-light border mb-2 py-1" role="alert">
        <small class="text-muted">
            <strong>Legend:</strong>
            <span class="ms-2"><code class="text-dark">–</code> short syllable</span>
            <span class="ms-3"><code class="text-dark">=</code> long syllable</span>
            <span class="ms-3"><code class="text-dark">X</code> flexible (short or long)</span>
        </small>
    </div>
    <!-- One block per line: original line, grid, bahr (+ deviations when inferred) -->
    <template x-for="(lineData, idx) in lineResults" :key="idx">
        <div class="my-5">
            <!-- Loading -->
            <div class="text-center py-3 text-muted" x-show="lineData.loading" x-text="'Scanning line ' + (idx + 1) + '…'"></div>
            <!-- Error -->
            <div class="alert alert-danger py-2" x-show="lineData.error && !lineData.loading" x-text="'Line ' + (idx + 1) + ': ' + lineData.error"></div>
            <!-- Result: original line + grid + bahr -->
            <div x-show="lineData.result && getDisplayCode(lineData.result)">
                <h5 class="text-center urdu-text mb-4" dir="rtl" lang="ur" x-text="lineData.result.original_line || lineData.lineText || ''"></h5>
                <div class="scansion-grid-wrapper">
                    <div class="scansion-row words-row">
                        <template x-for="wordData in getWordsWithBoundaries(lineData.result)" :key="wordData.word_index">
                            <div class="word-cell" :style="'grid-column: span ' + wordData.span" x-text="wordData.word"></div>
                        </template>
                    </div>
                    <div class="scansion-row">
                        <template x-for="(syllable, i) in getSyllablesWithDeviations(lineData.result)" :key="i">
                            <span class="syllable" :class="syllable.deviationType || ''" x-text="syllable.char || ''"></span>
                        </template>
                    </div>
                    <div class="scansion-row feet-row">
                        <template x-for="(footData, footIndex) in getFeetWithBoundaries(lineData.result)" :key="footData.start">
                            <div class="foot-cell" :class="{ 'foot-cell-alt': footIndex % 2 === 1 }" :style="'grid-column: span ' + footData.span" x-text="footData.foot"></div>
                        </template>
                    </div>
                </div>
                <div class="text-center mt-3" x-show="getBahrLabel(lineData.result) && getBahrName(lineData.result)">
                    <h6><span x-text="getBahrLabel(lineData.result)"></span><span dir="rtl" lang="ur" class="urdu-text" :data-bs-title="getBahrTooltip(lineData.result)" :data-bs-toggle="getBahrTooltip(lineData.result) ? 'tooltip' : null" data-bs-placement="top" x-text="getBahrName(lineData.result)"></span><span class="small text-muted" x-show="getDeviationsExplanationLine(lineData.result)" x-text="getDeviationsExplanationLine(lineData.result) ? '. ' + getDeviationsExplanationLine(lineData.result) : ''"></span></h6>
                </div>
            </div>
        </div>
    </template>

    <form @submit.prevent="submit" class="mb-4">
        <div class="mb-3">
            <label for="islah-text" class="form-label">Enter Urdu Poetry Lines (one per line)</label>
            <textarea id="islah-text" class="form-control form-control-lg urdu-input mb-3" dir="rtl" lang="ur" rows="5"
                placeholder="Start typing your poetry here..." x-model="text" :disabled="loading"
                @keydown.space="setTimeout(() => silentUpdate(), 0)"></textarea>
        </div>
        <button type="submit" class="btn btn-primary" :disabled="loading">
            <span x-show="!loading">Submit</span>
            <span x-show="loading">Submitting…</span>
        </button>
    </form>


</div>

<script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js"></script>
<script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('islahApp', () => ({
            text: '',
            lineResults: [],
            previousLines: [],
            loading: false,
            debounceTimer: null,

            init() {
                this.$watch('text', (value) => {
                    if (this.debounceTimer) clearTimeout(this.debounceTimer);
                    if (value.trim()) {
                        this.debounceTimer = setTimeout(() => {
                            this.debounceTimer = null;
                            if (!this.loading) this.silentUpdate();
                        }, 3000);
                    }
                });
            },

            getDisplayCode(result) {
                if (!result) return '';
                const useMeterPattern = result.analysis_level === 'meter' &&
                    (result.summary?.conforms_exactly === true || !!result.inferred_meter) &&
                    result.meter_pattern;
                return useMeterPattern ? result.meter_pattern : (result.full_code || '');
            },

            getWordsWithBoundaries(result) {
                if (!result || !result.word_boundaries || !result.original_line) return [];
                const words = result.original_line.trim().split(/\s+/).filter(w => w.length > 0);
                const boundaries = result.word_boundaries;
                const deviations = result.deviations || [];
                const insertions = deviations.filter(dev => dev.type === 'insert');
                return boundaries.map(wb => {
                    let span = wb.code_end - wb.code_start;
                    insertions.forEach(ins => {
                        if (ins.code_pos >= wb.code_start && ins.code_pos < wb.code_end) span += 1;
                    });
                    return { word_index: wb.word_index, word: words[wb.word_index] || '', span };
                });
            },

            getSyllablesWithDeviations(result) {
                const codeStr = this.getDisplayCode(result);
                if (!result || !codeStr) return [];
                const code = codeStr.split('');
                const deviations = result.deviations || [];
                const deviationMap = new Map();
                deviations.forEach(dev => {
                    if (dev.type === 'substitute' || dev.type === 'delete') deviationMap.set(dev.code_pos, dev);
                });
                const syllables = code.map((char, index) => ({
                    char,
                    index,
                    deviationType: deviationMap.has(index) ? deviationMap.get(index).type : null,
                    expected: deviationMap.has(index) ? deviationMap.get(index).expected : null,
                }));
                const insertions = deviations.filter(dev => dev.type === 'insert').sort((a, b) => b.code_pos - a.code_pos);
                insertions.forEach(ins => {
                    syllables.splice(ins.code_pos, 0, { char: '', index: ins.code_pos, deviationType: 'insert', expected: ins.expected });
                });
                return syllables;
            },

            getFeetWithBoundaries(result) {
                if (!result || !result.feet_list || !result.full_code) return [];
                const feet = result.feet_list;
                const deviations = result.deviations || [];
                const insertions = deviations.filter(dev => dev.type === 'insert');
                return feet.map(seg => {
                    let span = seg.end - seg.start;
                    insertions.forEach(ins => {
                        if (ins.code_pos >= seg.start && ins.code_pos < seg.end) span += 1;
                    });
                    return { foot: seg.foot, start: seg.start, span };
                });
            },

            getBahrLabel(result) {
                if (!result || result.analysis_level !== 'meter') return '';
                if (result.summary && result.summary.conforms_exactly === true) return 'Exact match: ';
                if (result.inferred_meter && result.inferred_meter.meter_name) return 'Almost matches: ';
                return '';
            },

            getBahrName(result) {
                if (!result || result.analysis_level !== 'meter') return '';
                if (result.summary && result.summary.conforms_exactly === true && result.meters && result.meters[0])
                    return result.meters[0].meter_name || '';
                if (result.inferred_meter && result.inferred_meter.meter_name) return result.inferred_meter.meter_name;
                return '';
            },

            getBahrTooltip(result) {
                if (!result) return '';
                if (result.inferred_meter && result.inferred_meter.meter_roman) return result.inferred_meter.meter_roman;
                if (result.meters && result.meters[0] && result.meters[0].meter_roman) return result.meters[0].meter_roman;
                return '';
            },

            getDeviationsExplanation(result) {
                if (!result || !result.inferred_meter || !result.deviations || !result.deviations.length) return [];
                return result.deviations.map(dev => {
                    const pos = dev.code_pos;
                    if (dev.type === 'substitute') return `Substitute ${dev.current ?? ''} with ${dev.expected ?? ''} at position ${pos}.`;
                    if (dev.type === 'insert') return `Insert ${dev.expected ?? ''} at position ${pos}.`;
                    if (dev.type === 'delete') return `Delete ${dev.current ?? ''} at position ${pos}.`;
                    return '';
                }).filter(Boolean);
            },

            getDeviationsExplanationLine(result) {
                const lines = this.getDeviationsExplanation(result);
                return lines.length ? lines.join(' ') : '';
            },

            async submit() { return this.runLines(true); },
            async silentUpdate() { return this.runLines(false); },

            async runLines(explicit) {
                if (this.debounceTimer) {
                    clearTimeout(this.debounceTimer);
                    this.debounceTimer = null;
                }
                const textarea = document.getElementById('islah-text');
                const currentLines = this.text.split('\n').map(l => l.trim()).filter(Boolean);

                if (currentLines.length === 0) {
                    this.lineResults = [];
                    this.previousLines = [];
                    if (explicit) this.$nextTick(() => textarea?.focus());
                    return;
                }

                const needFetch = [];
                for (let i = 0; i < currentLines.length; i++) {
                    if (i >= this.previousLines.length || currentLines[i] !== this.previousLines[i]) needFetch.push(i);
                }

                const newLineResults = currentLines.map((lineText, i) => {
                    if (needFetch.includes(i)) {
                        return { lineIndex: i, lineText, result: null, error: null, loading: true };
                    }
                    return (this.lineResults[i] && this.lineResults[i].lineText === lineText)
                        ? this.lineResults[i]
                        : { lineIndex: i, lineText, result: null, error: null, loading: false };
                });

                this.lineResults = newLineResults;
                if (explicit) this.loading = true;

                try {
                    for (const i of needFetch) {
                        try {
                            const res = await fetch('/api/islah', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ text: currentLines[i] }),
                            });
                            const raw = await res.text();
                            if (!res.ok) {
                                this.lineResults = this.lineResults.map((entry, idx) =>
                                    idx === i ? { ...entry, result: null, error: raw || `HTTP ${res.status}`, loading: false } : entry
                                );
                            } else {
                                try {
                                    const result = JSON.parse(raw);
                                    this.lineResults = this.lineResults.map((entry, idx) =>
                                        idx === i ? { ...entry, result, error: null, loading: false } : entry
                                    );
                                } catch (_) {
                                    this.lineResults = this.lineResults.map((entry, idx) =>
                                        idx === i ? { ...entry, result: null, error: 'Invalid JSON', loading: false } : entry
                                    );
                                }
                            }
                        } catch (err) {
                            this.lineResults = this.lineResults.map((entry, idx) =>
                                idx === i ? { ...entry, result: null, error: err.message || 'Request failed', loading: false } : entry
                            );
                        }
                    }
                    this.previousLines = currentLines.slice();
                } finally {
                    if (explicit) this.loading = false;
                    if (explicit) this.$nextTick(() => textarea?.focus());
                }
            },
        }));
    });
</script>
{% endblock %}