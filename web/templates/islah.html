{% extends "base.html" %}

{% block title %}Islah — Aruuz Nigar{% endblock %}

{% block extra_head %}
<style>
    [x-cloak] {
        display: none !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="container my-5" x-data="islahApp()" x-cloak>
    <h1 class="text-center mb-4">Islah</h1>

    <form @submit.prevent="submit" class="mb-4">
        <div class="mb-3">
            <label for="islah-text" class="form-label">Enter Urdu Poetry Lines (one per line)</label>
            <textarea id="islah-text" class="form-control form-control-lg urdu-input mb-3" dir="rtl" lang="ur" rows="5"
                placeholder="Start typing your poetry here..." x-model="text" :disabled="loading"
                @keydown.space="setTimeout(() => silentUpdate(), 0)"></textarea>
        </div>
        <button type="submit" class="btn btn-primary" :disabled="loading">
            <span x-show="!loading">Submit</span>
            <span x-show="loading">Submitting…</span>
        </button>
    </form>

    <!-- Scansion grid: syllables, words, feet rows each have one grid; each syllable = one column -->
    <div class="my-3" x-show="result && displayCode">
        <!-- Words row -->
        <div class="scansion-row words-row">
            <template x-for="wordData in wordsWithBoundaries" :key="wordData.word_index">
                <div class="word-cell" :style="`grid-column: span ${wordData.span}`" x-text="wordData.word"></div>
            </template>
        </div>
        <!-- Syllables row -->
        <div class="scansion-row">
            <template x-for="(syllable, i) in syllablesWithDeviations" :key="i">
                <span class="syllable" :class="syllable.deviationType || ''" x-text="syllable.char || ''"></span>
            </template>
        </div>

        <!-- Feet row -->
        <div class="scansion-row feet-row">
            <template x-for="footData in feetWithBoundaries" :key="footData.start">
                <div class="foot-cell" :style="`grid-column: span ${footData.span}`" x-text="footData.foot"></div>
            </template>
        </div>
    </div>

    <div x-show="response !== ''">
        <label class="form-label">Response</label>
        <pre class="bg-light border rounded p-3 overflow-auto mb-0" x-text="response"></pre>
    </div>

</div>

<script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js"></script>
<script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('islahApp', () => ({
            text: '',
            response: '',
            result: null,
            loading: false,
            debounceTimer: null,

            init() {
                this.$watch('text', (value) => {
                    if (this.debounceTimer) clearTimeout(this.debounceTimer);
                    if (value.trim()) {
                        this.debounceTimer = setTimeout(() => {
                            this.debounceTimer = null;
                            if (!this.loading) this.silentUpdate();
                        }, 3000);
                    }
                });
            },

            get displayCode() {
                if (!this.result) return '';
                const useMeterPattern = this.result.analysis_level === 'meter' &&
                    (this.result.summary?.conforms_exactly === true || !!this.result.inferred_meter) &&
                    this.result.meter_pattern;
                return useMeterPattern ? this.result.meter_pattern : (this.result.full_code || '');
            },

            get wordsWithBoundaries() {
                if (!this.result || !this.result.word_boundaries || !this.result.original_line) {
                    return [];
                }

                // Split original line into words (handle Urdu text - split on spaces)
                const words = this.result.original_line.trim().split(/\s+/).filter(w => w.length > 0);
                const boundaries = this.result.word_boundaries;

                // Account for insertions when calculating span
                const deviations = this.result.deviations || [];
                const insertions = deviations.filter(dev => dev.type === 'insert');
                
                return boundaries.map(wb => {
                    // Calculate span accounting for insertions within this word's range
                    let span = wb.code_end - wb.code_start;
                    insertions.forEach(ins => {
                        if (ins.code_pos >= wb.code_start && ins.code_pos < wb.code_end) {
                            span += 1; // Each insertion adds one column
                        }
                    });
                    
                    return {
                        word_index: wb.word_index,
                        word: words[wb.word_index] || '',
                        span: span,
                    };
                });
            },

            get syllablesWithDeviations() {
                const codeStr = this.displayCode;
                if (!this.result || !codeStr) {
                    return [];
                }

                const code = codeStr.split('');
                const deviations = this.result.deviations || [];

                // Build a map of deviations by code_pos
                const deviationMap = new Map();
                deviations.forEach(dev => {
                    if (dev.type === 'substitute' || dev.type === 'delete') {
                        deviationMap.set(dev.code_pos, dev);
                    }
                });

                // Build array of syllables with deviation info
                const syllables = code.map((char, index) => ({
                    char: char,
                    index: index,
                    deviationType: deviationMap.has(index) ? deviationMap.get(index).type : null,
                    expected: deviationMap.has(index) ? deviationMap.get(index).expected : null,
                }));

                // Insert placeholder entries for insertions (sorted by code_pos descending to maintain order)
                const insertions = deviations
                    .filter(dev => dev.type === 'insert')
                    .sort((a, b) => b.code_pos - a.code_pos); // Sort descending to insert from end

                insertions.forEach(ins => {
                    // Insert at code_pos (before the syllable at that position)
                    syllables.splice(ins.code_pos, 0, {
                        char: '',
                        index: ins.code_pos,
                        deviationType: 'insert',
                        expected: ins.expected,
                    });
                });

                return syllables;
            },

            get feetWithBoundaries() {
                if (!this.result || !this.result.feet_list || !this.result.full_code) {
                    return [];
                }

                const feet = this.result.feet_list;
                const deviations = this.result.deviations || [];
                const insertions = deviations.filter(dev => dev.type === 'insert');

                return feet.map(seg => {
                    // Base span from start/end in code indices
                    let span = seg.end - seg.start;

                    // Account for insertions that fall within this foot's range
                    insertions.forEach(ins => {
                        if (ins.code_pos >= seg.start && ins.code_pos < seg.end) {
                            span += 1;
                        }
                    });

                    return {
                        foot: seg.foot,
                        start: seg.start,
                        span: span,
                    };
                });
            },

            async submit() {
                return this.doFetch(true);
            },

            async silentUpdate() {
                return this.doFetch(false);
            },

            async doFetch(explicit) {
                if (this.debounceTimer) {
                    clearTimeout(this.debounceTimer);
                    this.debounceTimer = null;
                }
                const textarea = document.getElementById('islah-text');
                if (explicit) this.loading = true;
                try {
                    const res = await fetch('/api/islah', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text: this.text }),
                    });
                    const raw = await res.text();
                    if (!res.ok) {
                        this.response = raw || `HTTP ${res.status}`;
                        this.result = null;
                    } else {
                        try {
                            this.result = JSON.parse(raw);
                            this.response = raw;
                        } catch (_) {
                            this.result = null;
                            this.response = raw;
                        }
                    }
                } catch (err) {
                    this.response = err.message || 'Request failed';
                } finally {
                    if (explicit) this.loading = false;
                    if (explicit) this.$nextTick(() => textarea?.focus());
                }
            },
        }));
    });
</script>
{% endblock %}